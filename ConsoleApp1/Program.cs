using C.Command.Pattern.Commands;
using C.Command.Pattern.Invokers;
using C.Command.Pattern.Macrocommands.Commands;
using C.Command.Pattern.Macrocommands.Invokers;
using C.Command.Pattern.Macrocommands.Receivers;
using C.Command.Pattern.Receivers;
using System;
using System.Collections.Generic;

namespace C.Command
{
    //Паттерн Команда позволят инкапсулировать запрос на выполнение определенного действия в виде отдельного объекта. Этот одэект запроса на действие
    //и называется коммандой. При этом объекты, инициализирующие запросы на выполнение действия, отделяются от объектов, которые выполняют это действие.
    //Комманды могут использовать параметры, которые передают ассоциированную с коммандой информацию. Кроме того, комманды могут ставиться в очередь
    //и также могут быть отменены.

    //Короче говоря у нас есть следующие участники: 1) Непосредственно сам интерфейс комманды, который декларирует какие-то методы, обычно это метод для
    //выполнения действия, а так же метод для отмены действия. 2) Конкретная комманда, которая реализует методы интерфейса. 3) Получатель комманды.
    //Определяет действия, которые должны выполняться в результате запроса. 4) Инициатор комманды. Вызывает комманду для выполнения определенного
    //запроса. 5) Ну и сам клиент. Создает комманду, устанавливает ее получателя.
    //Таким образом, инициатор, отправляющий запрос, ничего не знает о получателе, который будет выполнять комманду. К слову сказать, таких команд
    //мы можем насоздавать великое множество, просто унаследовавшись от интерфейса.

    //Вообще в C# команды применяются сплошь и рядом, обычно применяются во взаимодействии с пользователем.

    //Теперь более конкретный пример. Вот у нас есть телевизор и есть пульт. То есть у нас есть получатель- телевизор и инициатор- пульт.
    //Клиент- класс Program. Ну и также у нас есть интерфейс и его реализация, а так же пуста реализация NoCommand, которая установливается
    //по умолчанию. Сделали это для того, что если мы попытаемяся выполнить команду до ее назначения, у нас не вывалилось исключение. Так же, можно
    //было проверять команду на null в классе инициатора.
    //Наш пульт ничего не знает о телевизоре, он знает только как отправить комманду, и это очень хорошо, так как мы получаем гибкую систему, мы можем
    //легко менять команды, создавть последовательности комманд, и нам абсолютоно неважно сколько у нас получателей. Например помимо телевизора, у нас
    //появилась микроволновка, которой тоже неплохо дыло бы управлять с помощью интерфейса для этого достаточно добавить соответствующие классы и команды.
    //На пульте у нас может быть сколько угодно кнопок. Вот у нашего есть кнопка включения и кнопка регулировки громкости, и для этого пудьта как бы 2
    //получателя- класс TV и класс Volume (да да Volume оформлен в виде отдельного получателя, он управляет уровнем звука и сохраняет текущий уровень
    //в переменной level). Так как кнопки 2, значит и комманды 2- включение и регулировка громкости. Кнопки пульта мы оформили ввиде массива: первая для
    //TV, вторая для Volume. В качестве логгера мы использовали стэк.

    //На самом деле пример с пультом не очень хороший. Как бы не логично в получателях иметь целый телевизор и звук, как отдельного получателя.
    //Более подходящий пример рассмотрим на основе макрокоманды, то есть некой команды, которая управляет набором команд. Вот у нас есть программист,
    //тестировщик и маркетолог, каждый занят своим делом, то есть у менеджера, который ими управляет, в арсенале набор комманд для каждого из них,
    //однако категорически важен порядок выполнения, то есть маркетолог не долже начинать маркетинговую активность раньше чем начнет работу тестировщик
    //и программист, а, в свою очередь, тестировщик не может начать работу раньше чем ее начнет программист. Соответственно и заканчивают они тоже
    //в том же порядке. Вот как раз дабы это все организовать- менеджеру и нужна будет макрокоманда. Ему не нужно будет управлять процессом точечно,
    //ему достаточно будет обратиться к макрокоманде. В общем у нас тут целый букет организовывается, и порядок и очередь.

    //Исходя из вышеописанного делаем вывод, что паттерн Команда лучше использовать когда:
    // 1) Когда надо передавать в качестве параметров определенные действия, вызываемые в ответ на другие действия. То есть когда необходимы функции
    //    обратного действия в ответ на определенные действия.
    // 2) Когда необходимо обеспечить выполнение очереди запросов, а также их возможную отмену.
    // 3) Когда надо поддерживать логгирование изменений в результате запросов. Использование логов может помочь восстановить состояние системы -
    //    для этого необходимо будет использовать последовательность запротоколированных команд.


    class Program
    {
        static void Main(string[] args)
        {           
        }
        public static void MultiRemote()
        {
            TV tv = new TV();
            Volume volume = new Volume();
            RemoteControl remoteControl = new RemoteControl();

            remoteControl.SetCommand(0, new TVOnCommand(tv));
            remoteControl.SetCommand(1, new VolumeCommand(volume));
            //включаем телевизор
            remoteControl.PressButton(0);
            //увеличиваем громкость на 5
            for (int i = 0; i < 3; i++)
            {
                remoteControl.PressButton(1);
            }
            //для уменьшения громкости
            for (int i = 0; i < 4; i++)
            {
                remoteControl.PressUndo();
            }

            Console.ReadLine();
        }
        public static void MacroCommands()
        {
            Programmer programmer = new Programmer();
            Tester tester = new Tester();
            Marketer marketer = new Marketer();

            var commands = new List<C.Command.Pattern.Macrocommands.Commands.ICommand>
            {
                new CodeCommand(programmer),
                new TestCommand(tester),
                new AdvertizeCommand(marketer)
            };

            Manager manager = new Manager();
            manager.SetCommand(new MacroCommand(commands));
            manager.StartProject();
            manager.StopProject();
        }
    }
}
