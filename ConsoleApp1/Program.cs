using C.Command.Pattern.Commands;
using C.Command.Pattern.Invokers;
using C.Command.Pattern.Receivers;
using System;

namespace C.Command
{
    //Паттерн Команда позволят инкапсулировать запрос на выполнение определенного действия в виде отдельного объекта. Этот одэект запроса на действие
    //и называется коммандой. При этом объекты, инициализирующие запросы на выполнение действия, отделяются от объектов, которые выполняют это действие.
    //Комманды могут использовать параметры, которые передают ассоциированную с коммандой информацию. Кроме того, комманды могут ставиться в очередь
    //и также могут быть отменены.

    //Короче говоря у нас есть следующие участники: 1) Непосредственно сам интерфейс комманды, который декларирует какие-то методы, обычно это метод для
    //выполнения действия, а так же метод для отмены действия. 2) Конкретная комманда, которая реализует методы интерфейса. 3) Получатель комманды.
    //Определяет действия, которые должны выполняться в результате запроса. 4) Инициатор комманды. Вызывает комманду для выполнения определенного
    //запроса. 5) Ну и сам клиент. Создает комманду, устанавливает ее получателя.
    //Таким образом, инициатор, отправляющий запрос, ничего не знает о получателе, который будет выполнять комманду. К слову сказать, таких команд
    //мы можем насоздавать великое множество, просто унаследовавшись от интерфейса.

    //Вообще в C# команды применяются сплошь и рядом, обычно применяются во взаимодействии с пользователем.

    //Теперь более конкретный пример. Вот у нас есть телевизор и есть пульт. То есть у нас есть получатель- телевизор и инициатор- пульт.
    //Клиент- класс Program. Ну и также у нас есть интерфейс и его реализация, а так же пуста реализация NoCommand, которая установливается
    //по умолчанию. Сделали это для того, что если мы попытаемяся выполнить команду до ее назначения, у нас не вывалилось исключение. Так же, можно
    //было проверять команду на null в классе инициатора.
    //Наш пульт ничего не знает о телевизоре, он знает только как отправить комманду, и это очень хорошо, так как мы получаем гибкую систему, мы можем
    //легко менять команды, создавть последовательности комманд, и нам абсолютоно неважно сколько у нас получателей. Например помимо телевизора, у нас
    //появилась микроволновка, которой тоже неплохо дыло бы управлять с помощью интерфейса для этого достаточно добавить соответствующие классы и команды.
    //На пульте у нас может быть сколько угодно кнопок. Вот у нашего есть кнопка включения и кнопка регулировки громкости, и для этого пудьта как бы 2
    //получателя- класс TV и класс Volume (да да Volume оформлен в виде отдельного получателя, он управляет уровнем звука и сохраняет текущий уровень
    //в переменной level). Так как кнопки 2, значит и комманды 2- включение и регулировка громкости. Кнопки пульта мы оформили ввиде массива: первая для
    //TV, вторая для Volume. В качестве логгера мы использовали стэк.


    class Program
    {
        static void Main(string[] args)
        {
            TV tv = new TV();
            Volume volume = new Volume();
            RemoteControl remoteControl = new RemoteControl();
            
            remoteControl.SetCommand(0, new TVOnCommand(tv));
            remoteControl.SetCommand(1, new VolumeCommand(volume));
            //включаем телевизор
            remoteControl.PressButton(0);
            //увеличиваем громкость на 5
            for (int i = 0; i < 5; i++)
            {
                remoteControl.PressButton(1);
            }
            //для уменьшения громкости
            for (int i = 0; i < 4; i++)
            {
                remoteControl.PressUndo();
            }

            Console.ReadLine();
        }
    }
}
