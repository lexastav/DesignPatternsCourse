using System;
using System.Threading;
using C.Singleton.Pattern.Realization1;
using C.Singleton.Pattern.Realization2;
using C.Singleton.Pattern.Realization3;
using C.Singleton.Pattern.Realization4;

namespace Singleton
{
    //Одиночка или синглтон- это достаточно простой в освоении порождающий паттерн с довольно простой концепцией.
    //Его применяют обычно тогда, когда необходимо что бы для класса существовал только один экземпляр. Это паттерн,
    //который гарантирует, что для определенного класса будет создан только один объект, а также предоставит к этому
    //объекту точку доступа. Неопытные разработчики для этих целей часто используют глобальные переменные,
    //ведь казалось бы, зачем городить усложненные конструкции, когда можно сделать глобальную переменную и не париться,
    //но вот как раз в отличии от глобальных переменных, синглтон позволяет создать объект только при его необходимости.
    //Если объект не нужен, то он созда не будет.
    
    //Далее рассмотрим примеры реализаций паттерна.

    class Program
    {
        static void Main(string[] args)
        {
            
        }
        static void StandartRealisation()
        {
            //Вот пример. Программа. На каждом компьютере можно одномоментно запустить только одну операционную систему.
            //В этом плане операционная система реализовывается через паттерн синглтон.
            //В классе определяется статическая переменная- ссылка на конкретный экземпляр данного объекта и приватный
            //конструктор. В статическом методе getInstance этот конструктор вызывается для создания объекта, если
            //объект отсутствует и равен null.

            //Вот все вроде понятно если речь идет про применение синглтона в рамках одного потока, а что если применять
            //паттерн в многопоточных программах? А в многопоточных программах могут возникнуть проблемы.

            //(приведенный ниже пример относится к многопотоку. Потокобезопасная реализация.)
            //{
            // вот что будет если запустить дополнительный поток в нашей программе.

            new Thread(() =>
            {
                Computer comp2 = new Computer();
                comp2.OS = OperationSystem.getInstance("Windows 10");
                Console.WriteLine(comp2.OS.Name);
            }).Start();

            //Рашифровка. Происходит то, что запускается дополнительный поток, который получает доступ к синглтону.
            //Параллельно выполняется тот код, который идет после запуска потока и который так же обращается к синглтону.
            //Короче говоря и главный, и дополнительный поток пытаются инициализировать синглтон с нужным значением.
            //Какое значение синглтон получит в итоге, предсказать в данном случае невозможно.
            //В итоге мы сталкиваемся с проблемой инициализации синглтона, когда оба потока одновременно обращаются к коду,
            //описывающего условие создания instance. Решить эту проблему можно путем заключения секции условия создания
            //instance в блок lock.
            //}

            //Потоконебезопасная реализация
            Computer comp = new Computer();
            comp.Launch("Debian");
            Console.WriteLine(comp.OS.Name);

            Console.ReadLine();

            // у нас не получится изменить ОС, так как объект уже создан

            comp.OS = OperationSystem.getInstance("Windows 10");
            Console.WriteLine(comp.OS.Name);

        }
        static void RealisationWithoutLock()
        {
            //потокобезопасная реализация без lock
            new Thread(() =>
            {
                SingleTon singleton1 = SingleTon.GetInstance();
                Console.WriteLine(singleton1.Date);
            }).Start();

            SingleTon singleton2 = SingleTon.GetInstance();
            Console.WriteLine(singleton2.Date);
        }
        static void LazyRealisation()
        {
            //Рассмотрим вариант ленивой реализации. Если мы определим объект синглтона в виде статического поля класса,
            //то это нам позволит как раз таки сделать ленивую реализацию, то есть данные будут инициализироваться
            //только перед непосредственным использованием, поскольку статические поля инициализируются перед первым
            //доступом к статическим членам класса и перед вызовом статического конструктора (если он есть).

            //Но у нас возникнет 2 проблемы:
            // 1) Класс синглтона может иметь множество статических переменных. Возможно мы вообще не будем обращаться
            //    к объекту синглтона, а будем использовать какие-то другие статические переменные.
            //    Расшифровка.
            //    Мы обращаемся к переменной text, но instance тоже будет инициализировано. Что бы этого избежать нам
            //    нужно создать внутренний класс, в который мы засунем статическую переменную, представляющую объект
            //    синглтона.
            // 2) Статические поля инициализируются перед первым доступом к статическим членам класса и перед вызовом
            //    статического конструктора. Но когда именно? Если класс содержит статические поля, не содержит
            //    статического конструктора, то время инициализации статических полей зависит от реализации платформы.
            //    Нередко это непосредственно перед первым использованием, но тем не менее момент точно не определен - это
            //    может происходить и чуть раньше. Однако если класс содержит статический конструктор, то статические
            //    поля будут инициализироваться непосредственно либо при создании первого экземпляра класса, либо при
            //    первом обращении к статическим членам класса. Проблему решает добавление статического конструктора
            //    во внутренний класс.
            Console.WriteLine($"Main {DateTime.Now.TimeOfDay}");
            Console.WriteLine(MyClass.text);

            MyClass singleton1 = MyClass.GetInstance();
            Console.WriteLine(singleton1.Date);
            Console.ReadLine();
            //Но вообще все это можно гораздо проще реализовать с использованием Lazy<T>
        }
        static void RealisationWithLazyT()
        {
            // Тут все просто, мы используем дженериковый тип Lazy<T>, что избавляет от необходимости создавать внутренний
            // класс.
            MyClass2 singleton = MyClass2.GetInstance();
            Console.WriteLine(singleton.Name);
        }
    }
}
